{"version":3,"file":"umd.js","sources":["../src/guards.ts","../src/compose.ts","../src/safe.ts","../src/object.ts","../src/array/guard.ts","../src/array/reduce.ts","../src/id.ts","../src/curry.ts","../src/number.ts","../src/array/actions.ts","../src/array/filter.ts","../src/boolean.ts","../src/console.ts","../src/memoize.ts","../src/string.ts","../src/async.ts","../src/generic.ts","../src/array/every.ts","../src/array/slice.ts","../src/array/join.ts","../src/array/map.ts","../src/array/some.ts","../src/array/sort.ts"],"sourcesContent":["export const isNull = (v: any): v is null | undefined => v == null;\nexport const isString = (v: any): v is string => typeof v === 'string';\n\nexport const testIf = <O>(condition: (x: any) => x is O) => <T>(\n  then: T\n) => (\n  otherValue: O | T\n) => condition(otherValue) ? then : otherValue;\n\n/**\n * Lazy defaulter.\n *\n * Helps with preventing `null`s or `undefined`s from sneaking into your values.\n *\n * @param defaultValue A value to take place\n * if a `null` or `undefined` comes instead of the original value\n *\n * @returns A function that accepts a nullable `original` value\n * and returns `defaultValue` if `original` is `undefined` or `null`,\n * `original` - otherwise\n */\nexport const ifNull = testIf(isNull);\n","/**\n * if you want more functions composed - add a typed overload yourself\n */\nexport const compose: {\n  /**\n   * Composes two functions together\n   *\n   * Will probably be redundant after the pipe operator gets merged\n   *\n   * ```ts\n  declare const price: number; // from server...\n\n  // Traditional way of doing this\n  const formatPrices = price => format(ConvertCurrency(price));\n\n  // Compose way of doing this\n  const formatPricesCompose = compose(format, ConvertCurrency);\n  ```\n  *\n  * @param f - first function\n  * @param g - second function\n  * @returns a function that calls these functions in order on a single argument\n  */\n  <T extends any[], U, V>(\n    f: (x: U) => V,\n    g: (...y: T) => U\n  ): {\n    <P extends T>(...p: P): V;\n    (...o: T): V;\n  };\n\n  /**\n   * Composes three functions together\n   *\n   * Will probably be redundant after the pipe operator gets merged\n   *\n   * ```ts\n  declare const prices: number[]; // from server...\n\n  // Traditional way of doing this\n  const totalPrice = prices => format(ConvertCurrency(prices.reduce((a, price) => a + price, 0)));\n\n  // Compose way of doing this\n  const totalPriceCompose = compose(format, ConvertCurrency, sum);\n  ```\n  *\n  * @param f - first function\n  * @param g - second function\n  * @param h - third function\n  * @returns a function that calls these functions in order on a single argument\n  */\n  <T, U, V, X extends any[]>(\n    f: (x: U) => V,\n    g: (y: T) => U,\n    h: (...z: X) => T\n  ): {\n    <P extends X>(...p: P): V;\n    (...o: X): V;\n  };\n\n  /**\n   * Composes four functions together\n   *\n   * Will probably be redundant after the pipe operator gets merged\n   *\n   * ```ts\n   * declare const prices: { price: number }[]; // from server...\n   *\n   * // Traditional way of doing this\n   * const sumOfFivePrices = prices => format(\n   *   ConvertCurrency(\n   *     prices\n   *       .slice(0, 5)\n   *       .reduce((sum, el) => sum + el.price, 0)\n   *   )\n   * );\n   *\n   * // Compose way of doing this\n   * const totalPriceCompose = compose(\n   *   format,\n   *   ConvertCurrency,\n   *   sum('price'),\n   *   slice(0, 5)\n   * );\n   * // or\n   * const totalPriceCompose = compose(\n   *   format,\n   *   ConvertCurrency,\n   *   reduce((a, b) => a + b.price, 0),\n   *   slice(0, 5)\n   * );\n   *  ```\n   *\n   * @param f - first function\n   * @param g - second function\n   * @param h - third function\n   * @param i - fourth function\n   * @returns a function that calls these functions in order on a single argument\n   */\n  <T, U, V, X, Y extends any[]>(\n    f: (x: U) => V,\n    g: (y: T) => U,\n    h: (z: X) => T,\n    i: (...a: Y) => X\n  ): {\n    <P extends Y>(...p: P): V;\n    (...o: Y): V;\n  };\n} = (...fns: Function[]) => (...x: any[]) => fns.reduceRight((arg, fn) => [(fn || ((_: any) => _))(...arg)], x)[0];\n","import { compose } from './compose';\nimport { ifNull } from './guards';\n\n/**\n * Nullable operations generator factory.\n *\n * Powerful fail-safe mechanism.\n *\n * @param defaultValue - A default to use instead of the null value\n * @returns a safeguard function\n */\nexport function createSafeOperation<T>(defaultValue: T) {\n  return <U extends T, R>(\n    action: (x: Readonly<U>) => R\n  ) => compose(\n    action,\n    ifNull(defaultValue as U)\n  );\n}\n","import { compose } from './compose';\nimport { createSafeOperation } from './safe';\nimport { Nullable } from './type';\n\n/**\n * Applies an operation to an object safely,\n * without failing on null or undefined\n */\nexport const safeObj = createSafeOperation<any>({} as any);\n\n/**\n * Maps object values by their keys (including symbols) into a new object\n *\n * Generaly equivalent to `Array.prototype.map()`\n */\nexport const mapObject = <T extends object, R>(\n  obj: T,\n  value: (key: keyof T) => R\n) => (\n  <Array<keyof T>>\n  [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)]\n).reduce((newObj, key) => (\n  newObj[key] = value(key), newObj\n), <Record<keyof T, R>> {});\n\n/**\n * Gets the array of keys of the given object (type-safe)\n */\nexport const keys = Object.keys as <T extends object>(o: T) => Array<keyof T>;\n\n/**\n * Lazily gets a value by key chain from the object.\n *\n * Unsafe - fails when the object is `null` or `undefined`\n */\nexport const fromPath = (...path: string[]) => <T extends object>(obj: T): any => path.reduce((o, i) => (\n  Object(o) === o ? o[i] : o\n), obj);\n\nexport const key: {\n  /**\n   * Lazily gets a value by key from the object.\n   *\n   * Safe, doesn't fail even if the object is `null` or `undefined`.\n   */\n  <T, K extends keyof T>(key: K): (obj: Nullable<T>) => T[K];\n\n  /**\n   * Lazily gets a value by key chain from the object.\n   *\n   * Safe, doesn't fail even if the object is `null` or `undefined`.\n   */\n  (...keys: string[]): (obj: any) => any;\n} = compose(\n  safeObj,\n  fromPath\n);\n","import { createSafeOperation } from '../safe';\n\nexport const safeArr = createSafeOperation<Array<any>>([]);\n","import { Nullable } from '../type';\nimport { safeArr } from './guard';\n\nexport const reduce: {\n  /**\n   * Lazy version of Array.prototype.reduce()\n   *\n   * Remembers the callback to apply it to the array later on.\n   *\n   * In case of array being `null` or `undefined` just applies the callback to an empty array.\n   *\n   * @param f - A callback for the reduce function.\n   * @returns A function that reduces an array using the remembered callback.\n   */\n  <T>(f: (p: T, c: T, i: number, arr: Readonly<T[]>) => T): (arr: Readonly<Nullable<T[]>>) => T;\n\n  /**\n   * Lazy version of Array.prototype.reduce()\n   *\n   * Remembers the callback to apply it to the array later on.\n   *\n   * In case of array being `null` or `undefined` just applies the callback to an empty array.\n   *\n   * @param f - A callback for the reduce function.\n   * @param init - A callback for the reduce function.\n   * @returns A function that reduces an array using the remembered callback.\n   */\n  <T, R = T>(\n    f: (p: R, c: T, i: number, arr: Readonly<T[]>) => R,\n    init: R\n  ): (arr: Readonly<Nullable<T[]>>) => R;\n\n  /**\n   * Lazy version of Array.prototype.reduce()\n   *\n   * Remembers the callback to apply it to the array later on.\n   *\n   * In case of array being `null` or `undefined` just applies the callback to an empty array.\n   *\n   * @param f - A callback for the reduce function.\n   * @param [init] - [optional] A callback for the reduce function.\n   * @returns A function that reduces an array using the remembered callback.\n   */\n  <T, R>(f: (p: R, c: T, i: number, arr: Readonly<T[]>) => R, init?: R): (arr: Readonly<Nullable<T[]>>) => R;\n} = <T, R>(\n  f: (p: R | T, c: T, i: number, arr: Readonly<T[]>) => R,\n  init?: R | T\n): (arr: Readonly<Nullable<T[]>>) => R | T => safeArr<T[], R | T>(_ => _.reduce(f, init as R | T));\n\n/**\n * Lazy version of Array.prototype.reduceRight()\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param f - A callback for the reduce function.\n * @param [init] - [optional] A callback for the reduce function.\n * @returns A function that reduces an array backwards using the remembered callback.\n */\nexport const reduceRight = <U, T>(\n  f: (p: U, c: T, i: number, arr: Readonly<T[]>) => U,\n  init: U\n) => safeArr<T[], U>(_ => _.reduceRight(f, init));\n\n/**\n * Pure version of Array.prototype.reverse()\n *\n * Doesn't modify the original array, returns a fresh and reversed one.\n *\n * In case of original array being `null` or `undefined` just returns an empty array.\n *\n * @param arr - Array to reverse.\n * @returns A new array with reverse order of elements.\n */\nexport const reverse = <T>(arr?: T[] | null) => reduceRight<T[], T>((arr, el) => (arr.push(el), arr), [])(arr);\n","/**\n * Identity function.\n *\n * Exists to do nothing.\n * @param X - a parameter to do nothing with\n * @returns `X`, the same as it was before\n */\nexport const id: {\n  /**\n   * Identity function.\n   *\n   * Exists to do nothing, but in a clever way:\n   * it adapts the types from the context.\n   * @param X - a parameter to do nothing with\n   * @returns `X`, the same as it was before\n   */\n  <X, Y = X>(X: X): Y;\n\n  /**\n   * Identity function.\n   *\n   * Exists to do nothing, while preserving the type.\n   * @param X - a parameter to do nothing with\n   * @returns `X`, the same as it was before\n   */\n  <X>(X: X): X;\n\n  /**\n   * Identity function.\n   *\n   * Exists to do nothing.\n   * @param X - a parameter to do nothing with\n   * @returns `X`, the same as it was before\n   */\n  (X: any): any;\n} = <X>(X: X): X => X;\n","export function curry<A, B, R>(fn: (a: A, b: B) => R): {\n  (): (a: A) => (b: B) => R;\n  (): (a: A, b: B) => R;\n  (a: A): (b: B) => R;\n  (a: A, b: B): R;\n};\n\nexport function curry<A, B, C, R>(fn: (a: A, b: B, c: C) => R): {\n  (): (a: A) => (b: B) => (c: C) => R;\n  (): (a: A) => (b: B, c: C) => R;\n  (): (a: A, b: B) => (c: C) => R;\n  (): (a: A, b: B, c: C) => R;\n  (a: A): (b: B) => (c: C) => R;\n  (a: A): (b: B, c: C) => R;\n  (a: A, b: B): (c: C) => R;\n  (a: A, b: B, c: C): R;\n};\n\nexport function curry(fn: Function) {\n  const arity = fn.length;\n\n  return function curried(...args: any[]): any {\n    if (args.length < arity) {\n      return curried.bind(null, ...args);\n    }\n\n    return fn(...args);\n  };\n}\n","import { curry } from './curry';\n\n/**\n * Consequently adds two numbers together.\n *\n * Can be partially called.\n */\nexport const add = curry((a: number, b: number) => b + a);\n\n/**\n * Consequently subtracts two numbers.\n *\n * Can be partially called.\n */\nexport const subtract = curry((a: number, b: number) => b - a);\n\n/**\n * Consequently multiplies two numbers.\n *\n * Can be partially called.\n */\nexport const multiply = curry((a: number, b: number) => b * a);\n\n/**\n * Consequently divides the second number by first.\n *\n * Can be partially called.\n * @param a - the number to divide by\n * @param b - the divisible number\n */\nexport const divide = curry((a: number, b: number) => b / a);\n\n/**\n * Powers the second number by first.\n *\n * Can be partially called.\n * @param a - the number to power by (exponent)\n * @param b - the original number\n */\nexport const pow = curry((b: number, a: number) => Math.pow(a, b));\n\nexport const toFixed = curry((digits: number | undefined, x: number) => x.toFixed(digits));\nexport const toPrecision = curry((digits: number | undefined, x: number) => x.toPrecision(digits));\nexport const toExponential = curry((digits: number | undefined, x: number) => x.toExponential(digits));\n","import { Nullable } from '../type';\nimport { safeObj } from '../object';\nimport { reduce } from './reduce';\nimport { id } from '../id';\nimport { add } from '../number';\n\nconst isPropKey = <T = object>(v: any): v is keyof T => typeof v === 'string' || typeof v === 'number' || typeof v === 'symbol';\n\n/**\n * Provides overloads for applying some action on reducing the array.\n */\ntype ReduceAction<R> = {\n  /**\n   * Perform lazy action on the array\n   *\n   * @param f - A getter function to get an element suitable for action.\n   * @returns a function, which peforms the action on all elements in the array using the getter function `f`.\n   */\n  <T>(f: (x: T) => R): (arr: Nullable<T[]>) => R;\n\n\n  /**\n   * Perform lazy action on the array elements' props.\n   *\n   * @param prop - A string key of the prop of suitable type in an element of the array.\n   * @returns a function, which peforms the action on all given props of elements in the array.\n   */\n  <T>(prop: keyof T): (arr: Nullable<T[]>) => R;\n\n  /**\n   * Perform the action on the array elements.\n   *\n   * Works only on arrays of the given type.\n   *\n   * @returns a result of the action performed.\n   */\n  <T>(arr: Nullable<T[]>): R;\n};\n\n/**\n * Creates a function that performs an action on all elements of the array,\n * using the `reduce()` function.\n *\n * @param act - A reducing action to perform on the array elements\n * @param [init] - [optional] initial value for the `reduce` function\n * @returns a final action function\n */\nexport const action = <R>(act: (a: R, b: R) => R, init?: R): ReduceAction<R> => function <T>(\n  arrOrProp?: Nullable<R[]> | keyof T | ((x: T) => R)\n) {\n  const getProp = typeof arrOrProp === 'function'\n    ? safeObj<T, R>(arrOrProp)\n    : isPropKey<T>(arrOrProp)\n      ? safeObj((_: T) => _[arrOrProp])\n      : id;\n\n  return reduce<T, R>((a, b) => act(a, getProp(b)), init);\n} as ReduceAction<R>;\n\ntype SummableKeys<T> = {\n  [key in keyof T]: T[key] extends string | number ? key : never\n}[keyof T];\n\n/**\n * Lazy summation (sum) of the array elements.\n */\nexport const sum: {\n  /**\n   * Lazy summation (sum) of the array elements.\n   *\n   * @param f - A getter function for a numbered element\n   * or a number representation of an element of the array.\n   * @returns a function, which sums all elements in the array using the getter function `f`.\n   */\n  <T>(f: (x: T) => number): (arr: Nullable<T[]>) => number;\n\n  /**\n   * Lazy summation (sum) of the array elements' props.\n   *\n   * @param prop - A string key of the prop of type `number` in an element of the array.\n   * @returns a function, which sums all given props of elements in the array.\n   */\n  <T>(prop: SummableKeys<T>): (arr: Nullable<T[]>) => number;\n\n  /**\n   * Summation (sum) of the array elements.\n   *\n   * Works only on arrays of numbers.\n   *\n   * @returns a sum of all numbers in the array.\n   */\n  (arr: Nullable<number[]>): number;\n} = action<number>(add, 0);\n","import { safeArr } from './guard';\nimport { Nullable } from '../type';\nimport { Comparator } from '../generic';\n\nexport const filter: {\n  /**\n   * Lazy version of Array.prototype.filter()\n   *\n   * Remembers the callback to apply it to the array later on.\n   *\n   * In case of array being `null` or `undefined` just applies the callback to an empty array.\n   *\n   * @param f - A callback for the filter function, should return a boolean.\n   * @returns A function that filters an array using the remembered callback.\n   */\n  <T>(f: (x: T, i: number, arr: readonly T[]) => boolean): (arr: Nullable<Readonly<T[]>>) => T[];\n\n  /**\n   * Lazy version of Array.prototype.filter()\n   *\n   * Remembers the callback to apply it to the array later on.\n   *\n   * In case of array being `null` or `undefined` just applies the callback to an empty array.\n   *\n   * @param f - A callback for the filter function, should return a boolean.\n   * @returns A function that filters an array using the remembered callback.\n   */\n  <T, R extends T>(f: (x: T, i: number, arr: readonly T[]) => x is R): (arr: Nullable<Readonly<T[]>>) => R[];\n} = <T>(\n  f: (x: T, i: number, arr: readonly T[]) => boolean\n): (arr: Nullable<Readonly<T[]>>) => T[] => safeArr<T[], T[]>(_ => _.filter(f));\n\n/**\n * Returns a function that checks if an element is a part of the array.\n *\n * @param many - array to be checked against\n */\nexport const isOneOf = <T>(many: T[]) => (x: T) => many.includes(x);\n\n/**\n * Checks the uniqeness of an array item based on a comparator function\n *\n * @param equals a function that determines if two elements are equal\n */\nexport const isElementUnique = <T>(\n  equals: Comparator<T> = (a, b) => a === b\n) => (el: T, i: number, arr: readonly T[]) => arr.findIndex(newEl => equals(newEl, el)) === i;\n\n/**\n * Removes duplicates from an array based on the result of an `equals` function\n *\n * @param equals a function that determines if two elements are equal\n */\nexport const unique = <T>(equals: Comparator<T> = (a, b) => a === b) => filter<T>(\n  isElementUnique<T>(equals)\n);\n\n","/**\n * Creates a boolean composer based on a boolean operator function\n *\n * @param operator a function that takes two boolean and returns another boolean\n * @returns a composer of boolean-returning operations\n */\nexport const composeBools = (\n  operator: (left: boolean, right: boolean) => boolean\n) => <T>(\n  ...fns: Array<(x: T, i: number, arr: readonly T[]) => boolean>\n) => fns.reduce((lf, rf) => (x: T, i, arr) => operator(lf(x, i, arr), rf(x, i + 1, arr)));\n\n/**\n * Composes boolean-returning operations together using \"and\" operation\n *\n * @returns a function that computes the result for an element\n */\nexport const and = composeBools((l, r) => l && r);\n\n/**\n * Composes boolean-returning operations together using \"or\" operation\n *\n * @returns a function that computes the result for an element\n */\nexport const or = composeBools((l, r) => l || r);\n\n/**\n * Composes boolean-returning operations together using \"xor\" operation\n *\n * @returns a function that computes the result for an element\n */\nexport const either = composeBools((l, r) => (l && !r) || (r && !l));\n\n/**\n * Inverses a boolean-returning function\n *\n * ```ts\n * const isNotArray = not(Array.isArray);\n * ```\n *\n * @param f a function that returns a boolean\n * @returns the same function but with inversed boolean output\n */\nexport const not = <F extends (...args: any[]) => boolean>(f: F): F => ((...args: Parameters<F>) => !f(...args)) as F;\n","/**\n * Makes a pure identity function out of any logging function\n *\n * @param messager - the logging function to purify\n */\nconst purifyLog = (messager: (...messages: any) => void) => (...messages: any) => <T>(x: T) => (messager(...messages, x), x);\n\n/** Lazily logs the element in the composition chain with some messages */\nexport const log = purifyLog(console.log);\n\n/** Lazily logs via console.warn the element in the composition chain with some messages */\nexport const warn = purifyLog(console.warn);\n\n/** Lazily errors (via console.error) the element in the composition chain with some messages */\nexport const error = purifyLog(console.error);\n","const recordExistsIn = (cache: Record<string, any>) => (paramsHash: string) => typeof cache[paramsHash] !== 'undefined';\nconst hashFunction = <P extends any[]>(\n  hash?: (...args: P) => string\n): ((args: P) => string) => hash ? (_: P) => hash(..._) : JSON.stringify;\n\n/**\n * Creates a function which caches its result based on parameters.\n * It's possible to customize the caching behaviour using the second argument - [hash].\n *\n * Works well with long, expensive computations, such as API requests or array operations.\n *\n *\n * @param f - A function to be cached.\n * Can only be a PURE function, e.g. a function which always gives the same output, given the same input.\n * @param [hash] - Custom hash function for parameters. Accepts all of the function's parameters,\n * should return a string, which will then be used as a hash key.\n * @returns - A cached function,\n * virtually identical to the original.\n */\nexport function memoize<\n  F extends (...args: any) => any\n>(f: F, hash?: (...args: Parameters<F>) => string): F & { original: F } {\n  const cache: Record<string, any> = {};\n  const isCached = recordExistsIn(cache);\n  const hashParams = hashFunction(hash);\n\n  const memoized = function (...args: any[]) {\n    const hashedArgs = hashParams(args as Parameters<F>);\n\n    let result: ReturnType<F>;\n\n    if (isCached(hashedArgs)) {\n      result = cache[hashedArgs];\n    } else {\n      result = cache[hashedArgs] = f(...args);\n    }\n\n    return result;\n  } as F & { original: F };\n\n  memoized.original = f;\n\n  return memoized;\n}\n\n/**\n * A decorator factory for memoization of class methods.\n *\n * ```ts\n * class MathJS {\n *   \\@Memoize((a, b) => (a + b))\n *   add(a: number, b: number) {\n *     return fetch(`http://api.mathjs.org/v4/?expr=${a}+${b}`)\n *       .then(_ => _.json());\n *   }\n * }\n *\n * // Then\n *\n * const math = new MathJS();\n *\n * math.add(2, 3);\n * // Request sent to `http://api.mathjs.org/v4/?expr=2+3` ...\n * // Delay...\n * // Result: `Promise<5>`\n *\n * // After some time, we call it again:\n * math.add(2, 3);\n * // Result: `Promise<5>`\n * // No delays! Value from local cache!\n * ```\n *\n * @param [hash] - Custom hash function for parameters. Accepts all of the methods's parameters,\n * should return a string, which will then be used as a hash key.\n */\nexport function Memoize(hash?: (...args: any[]) => string): MethodDecorator {\n  return function (target, key, desc) {\n    Object.defineProperty(target, key, {\n      ...desc,\n      value: memoize(desc.value as any, hash),\n    });\n\n    return Object.getOwnPropertyDescriptor(target, key);\n  };\n}\n","import { createSafeOperation } from './safe';\nimport { GetFKeys, GetF } from './type';\n\nexport const safeStr = createSafeOperation<string>('');\n\n/**\n * Lazifies any String.prototype method - makes it lazy and composable.\n *\n * @param methodName - the name of the method to uncurry\n * @returns a new lazy pure function\n */\nfunction lazyStrMethod<M extends GetFKeys<String>>(methodName: M) {\n  const method: Function = String.prototype[methodName];\n\n  return (...args: Parameters<GetF<String, M>>) => safeStr(\n    (s): ReturnType<GetF<String, M>> => method.apply(s, args)\n  );\n}\n\n/**\n * Lazily matches a pattern that supports being matched against,\n * and returns function that returns an array containing the results of that search.\n * @param matcher An object that supports being matched against\n * @returns a function that performs the given match on a string argument\n */\nexport const match = (pattern: RegExp) => safeStr(s => s.match(pattern) || []);\n\n/**\n * Finds the first substring match in a regular expression search.\n * @param pattern The regular expression pattern and applicable flags.\n */\nexport const search = (pattern: string | RegExp) => safeStr(s => s.search(pattern));\n\n/**\n * Lazily returns a check function that indicates\n * whether or not a pattern exists in a searched string.\n *\n * @param matcher An object that supports being matched against\n * @returns a function that performs the given test on a string argument\n */\nexport const test = (pattern: RegExp) => safeStr(s => pattern.test(s));\n\nexport const replace: {\n  (match: RegExp | string, replace: string): (s: string) => string;\n  (match: RegExp | string, replacer: (substring: string, ...args: any[]) => string): (s: string) => string;\n} = lazyStrMethod('replace') as any;\n\nexport const prepend = (prefix: string) => safeStr(s => prefix.concat(s));\n\n/**\n * Returns a string that contains the concatenation of two or more strings.\n * @param args The strings to append to the end of the string.\n */\nexport const append = lazyStrMethod('concat');\n\n/**\n * Lazily split a string into substrings using the specified separator and return them as an array.\n * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.\n * @param limit A value used to limit the number of elements returned in the array.\n */\nexport const split = (separator: string | RegExp, limit?: number) => safeStr(s => s.split(separator, limit));\n\n/**\n * Gets a substring beginning at the specified location and having the specified length.\n * @param from The starting position of the desired substring. The index of the first character in the string is zero.\n * @param length The number of characters to include in the returned substring.\n */\nexport const substr = lazyStrMethod('substr');\n\n/** Converts all the alphabetic characters in a string to uppercase. */\nexport const toUpperCase = lazyStrMethod('toUpperCase')();\n\n/** Converts all the alphabetic characters in a string to lowercase. */\nexport const toLowerCase = lazyStrMethod('toLowerCase')();\n\n/** Removes the leading and trailing white space and line terminator characters from a string. */\nexport const trim = lazyStrMethod('trim')();\n\nexport const startsWith = lazyStrMethod('startsWith');\n\nexport const endsWith = lazyStrMethod('endsWith');\n\nexport const getDigits = replace(/[^0-9]/g, '');\n\nexport { concat, includes } from './generic';\n","export function then<T, R>(res: (x: T) => R): (px: Promise<T>) => R extends Promise<infer RR> ? Promise<RR> : Promise<R> {\n  return (px: Promise<T>) => px.then(res) as any;\n}\n\nexport function capture<T, R>(rej: (e: any) => R): (px: Promise<T>) => Promise<T | R> {\n  return (px: Promise<T>) => px.catch(rej);\n}\n","/**\n * Generic lazy `concat()` function.\n *\n * Works on anything that has the compatible concat method\n * @param args The elements to concat\n * @returns a function which accepts the item to perform the concatenation on\n */\nexport const concat = <T extends { concat(...args: T[]): T }>(...args: T[]) => (b: T): T => b.concat(...args);\n\ntype Includes<X> = { includes(x: X): boolean };\n\n/**\n * Generic lazy `includes()` function.\n *\n * Works on anything that has the compatible `includes()` method\n * @param x The element to check\n * @returns a function which accepts the item to perform the test on\n */\nexport const includes = <X>(x: X) => <T extends Includes<X>>(b: T) => b.includes(x);\n\n\nexport type Comparator<T> = (el1: T, el2: T) => boolean;\n\n/**\n * Compare two objects by a property\n * using a comparator function (default - `===`)\n *\n * @param key - property key to compare objects by\n * @param [compare=(el1, el2) => el1 === el2] - comparator to compare the properties by\n */\nexport const compareBy = <Key extends PropertyKey, TK = any>(\n  key: Key,\n  compare: Comparator<TK> = (el1, el2) => el1 === el2\n) => <T extends Record<Key, TK>>(\n  el1: T, el2: T\n) => compare(el1[key], el2[key]);\n","import { safeArr } from './guard';\n\n/**\n * Lazy version of Array.prototype.every(),\n * which returns true if the callback yields `true` for every element of the array.\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the `every()` to an empty array.\n *\n * @param f - A callback for the `every()` function, should return a boolean.\n * @returns A function that checks the array using the remembered callback.\n */\nexport const every = <T>(f: (x: T, i: number, array: readonly T[]) => boolean) => safeArr<T[], boolean>(_ => _.every(f));\n","import { safeArr } from './guard';\nimport { Nullable } from '../type';\n\n/**\n * Lazy version of Array.prototype.slice(), which returns a section of an array.\n *\n * Remembers the arguments to apply them to the array.slice() later on.\n *\n * In case of array being `null` or `undefined` just applies the `slice()` to an empty array.\n *\n * @param [start] - The beginning of the specified portion of the array.\n * @param [end] - The end of the specified portion of the array.\n * @returns A function that slices an array using the remembered arguments.\n */\nexport const slice = <T>(start?: number, end?: number) => safeArr<T[], T[]>(_ => _.slice(start, end));\n\nexport const first = <T>(\n  arr?: Nullable<T[]>\n): T | undefined => safeArr<T[], T | undefined>(_ => _[0])(arr);\n\nexport const last = <T>(\n  arr?: Nullable<T[]>\n): Nullable<T> => safeArr<T[], T | undefined>(_ => _.length === 0 ? _[0] : _[_.length - 1])(arr);\n","import { safeArr } from './guard';\n\n/**\n * Lazy version of Array.prototype.join()\n *\n * Remembers the separator to join the array by it later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param separator - A string to join by.\n * @returns A function that joins an array using the remembered separator.\n */\nexport const join = (separator: string = '') => safeArr(_ => _.join(separator));\n","import { safeArr } from './guard';\n\n/**\n * Lazy version of Array.prototype.map()\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param f - A callback for the map function.\n * @returns A function that maps an array into a different array using the remembered callback.\n */\nexport const map = <T, R>(f: (x: T, i: number, arr: Readonly<T[]>) => R) => safeArr<T[], R[]>(_ => _.map<R>(f));\n","import { safeArr } from './guard';\n\n/**\n * Lazy version of Array.prototype.some(),\n * which returns true if the callback yields `true` for at least one element of the array.\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the `some()` to an empty array.\n *\n * @param f - A callback for the `some()` function, should return a boolean.\n * @returns A function that checks the array using the remembered callback.\n */\nexport const some = <T>(f: (x: T, i: number, array: readonly T[]) => boolean) => safeArr<T[], boolean>(_ => _.some(f));\n","import { safeArr } from './guard';\n\n/**\n * Pure lazy version of Array.prototype.sort():\n * - if a callback returns a negative number - make `a` lower than `b`\n * - if a callback returns a 0 - leave order unchanged\n * - if a callback returns a positive number - make `b` lower than `a`\n *\n * Doesn't modify the original array, returns a fresh and sorted one.\n *\n * In case of original array being `null` or `undefined` just returns an empty array.\n *\n * @param f - a compare function.\n * @returns A function that accepts an array to sort.\n */\nexport const sort = <T>(f?: (a: T, b: T) => number) => safeArr<T[], T[]>(_ => _.slice().sort(f));\n"],"names":["condition","compose","fns","x","reduceRight","arg","fn","_","ifNull","v","then","otherValue","createSafeOperation","defaultValue","action","safeObj","keys","Object","fromPath","path","obj","reduce","o","i","key","safeArr","f","init","id","X","curry","arity","length","curried","args","bind","add","a","b","subtract","multiply","divide","pow","Math","toFixed","digits","toPrecision","toExponential","act","arrOrProp","getProp","_typeof","sum","filter","isElementUnique","equals","el","arr","findIndex","newEl","composeBools","operator","lf","rf","and","l","r","or","either","purifyLog","messager","messages","log","console","warn","error","recordExistsIn","cache","paramsHash","hashFunction","hash","JSON","stringify","memoize","isCached","hashParams","memoized","hashedArgs","original","safeStr","lazyStrMethod","methodName","method","String","prototype","s","apply","replace","append","substr","toUpperCase","toLowerCase","trim","startsWith","endsWith","getDigits","target","desc","defineProperty","value","getOwnPropertyDescriptor","rej","px","compare","el1","el2","concat","every","includes","many","separator","join","map","getOwnPropertySymbols","newObj","pattern","match","prefix","push","search","start","end","slice","some","sort","limit","split","test","res"],"mappings":"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"}