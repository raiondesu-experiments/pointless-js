{"version":3,"file":"umd.js","sources":["../src/curry.ts","../src/number.ts","../src/compose.ts","../src/generic.ts","../src/object.ts","../src/array.ts","../src/boolean.ts","../src/console.ts","../src/memoize.ts","../src/string.ts","../src/async.ts"],"sourcesContent":["export function curry<A, B, R>(fn: (a: A, b: B) => R): {\n  (): (a: A) => (b: B) => R;\n  (): (a: A, b: B) => R;\n  (a: A): (b: B) => R;\n  (a: A, b: B): R;\n};\n\nexport function curry<A, B, C, R>(fn: (a: A, b: B, c: C) => R): {\n  (): (a: A) => (b: B) => (c: C) => R;\n  (): (a: A) => (b: B, c: C) => R;\n  (): (a: A, b: B) => (c: C) => R;\n  (): (a: A, b: B, c: C) => R;\n  (a: A): (b: B) => (c: C) => R;\n  (a: A): (b: B, c: C) => R;\n  (a: A, b: B): (c: C) => R;\n  (a: A, b: B, c: C): R;\n};\n\nexport function curry(fn: Function) {\n  const arity = fn.length;\n\n  return function curried(...args: any[]): any {\n    if (args.length < arity) {\n      return curried.bind(null, ...args);\n    }\n\n    return fn(...args);\n  };\n}\n","import { curry } from './curry';\n\n/**\n * Consequently adds two numbers together.\n *\n * Can be partially called.\n */\nexport const add = curry((a: number, b: number) => b + a);\n\n/**\n * Consequently subtracts two numbers.\n *\n * Can be partially called.\n */\nexport const subtract = curry((a: number, b: number) => b - a);\n\n/**\n * Consequently multiplies two numbers.\n *\n * Can be partially called.\n */\nexport const multiply = curry((a: number, b: number) => b * a);\n\n/**\n * Consequently divides the second number by first.\n *\n * Can be partially called.\n * @param a - the number to divide by\n * @param b - the divisible number\n */\nexport const divide = curry((a: number, b: number) => b / a);\n\n/**\n * Powers the second number by first.\n *\n * Can be partially called.\n * @param a - the number to power by (exponent)\n * @param b - the original number\n */\nexport const pow = curry((b: number, a: number) => Math.pow(a, b));\n\nexport const toFixed = curry((digits: number | undefined, x: number) => x.toFixed(digits));\nexport const toPrecision = curry((digits: number | undefined, x: number) => x.toPrecision(digits));\nexport const toExponential = curry((digits: number | undefined, x: number) => x.toExponential(digits));\n","/**\n * Composes two functions together\n *\n * Will probably be redundant after the pipe operator gets merged\n *\n * ```ts\ndeclare const price: number; // from server...\n\n// Traditional way of doing this\nconst formatPrices = price => format(ConvertCurrency(price));\n\n// Compose way of doing this\nconst formatPricesCompose = compose(format, ConvertCurrency);\n ```\n *\n * @param f - first function\n * @param g - second function\n * @returns a function that calls these functions in order on a single argument\n */\nexport function compose<T extends any[], U, V>(\n  f: (x: U) => V,\n  g: (...y: T) => U\n): {\n  <P extends T>(...p: P): V;\n  (...o: T): V;\n};\n\n/**\n * Composes three functions together\n *\n * Will probably be redundant after the pipe operator gets merged\n *\n * ```ts\ndeclare const prices: number[]; // from server...\n\n// Traditional way of doing this\nconst totalPrice = prices => format(ConvertCurrency(prices.reduce((a, price) => a + price, 0)));\n\n// Compose way of doing this\nconst totalPriceCompose = compose(format, ConvertCurrency, sum);\n ```\n *\n * @param f - first function\n * @param g - second function\n * @param h - third function\n * @returns a function that calls these functions in order on a single argument\n */\nexport function compose<T, U, V, X extends any[]>(\n  f: (x: U) => V,\n  g: (y: T) => U,\n  h: (...z: X) => T\n): {\n  <P extends X>(...p: P): V;\n  (...o: X): V;\n};\n\n/**\n * Composes four functions together\n *\n * Will probably be redundant after the pipe operator gets merged\n *\n * ```ts\n * declare const prices: { price: number }[]; // from server...\n *\n * // Traditional way of doing this\n * const sumOfFivePrices = prices => format(\n *   ConvertCurrency(\n *     prices\n *       .slice(0, 5)\n *       .reduce((sum, el) => sum + el.price, 0)\n *   )\n * );\n *\n * // Compose way of doing this\n * const totalPriceCompose = compose(\n *   format,\n *   ConvertCurrency,\n *   sum('price'),\n *   slice(0, 5)\n * );\n * // or\n * const totalPriceCompose = compose(\n *   format,\n *   ConvertCurrency,\n *   reduce((a, b) => a + b.price, 0),\n *   slice(0, 5)\n * );\n *  ```\n *\n * @param f - first function\n * @param g - second function\n * @param h - third function\n * @param i - fourth function\n * @returns a function that calls these functions in order on a single argument\n */\nexport function compose<T, U, V, X, Y extends any[]>(\n  f: (x: U) => V,\n  g: (y: T) => U,\n  h: (z: X) => T,\n  i: (...a: Y) => X\n): {\n  <P extends Y>(...p: P): V;\n  (...o: Y): V;\n};\n\n/**\n * if you want more functions composed - add a typed overload yourself\n */\nexport function compose(...fns: Function[]) {\n  return (...x: any[]) => fns.reduceRight((arg, fn) => [(fn || ((_: any) => _))(...arg)], x)[0];\n}\n","import { compose } from './compose';\n\n/**\n * Generic lazy `concat()` function.\n *\n * Works on anything that has the compatible concat method\n * @param args The elements to concat\n * @returns a function which accepts the item to perform the concatenation on\n */\nexport function concat<T extends { concat(...args: T[]): T }>(...args: T[]): (b: T) => T {\n  return b => b.concat(...args);\n}\n\ntype Includes<X> = { includes(x: X): boolean };\n\n/**\n * Generic lazy `includes()` function.\n *\n * Works on anything that has the compatible `includes()` method\n * @param x The element to check\n * @returns a function which accepts the item to perform the test on\n */\nexport function includes<X>(x: X): <T extends Includes<X>>(b: T) => boolean {\n  return b => b.includes(x);\n}\n\n/**\n * Identity function.\n *\n * Exists to do nothing.\n * @param X - a parameter to do nothing with\n * @returns `X`, the same as it was before\n */\nexport const id: {\n  /**\n   * Identity function.\n   *\n   * Exists to do nothing, but in a clever way:\n   * it adapts the types from the context.\n   * @param X - a parameter to do nothing with\n   * @returns `X`, the same as it was before\n   */\n  <X, Y = X>(X: X): Y;\n\n  /**\n   * Identity function.\n   *\n   * Exists to do nothing, while preserving the type.\n   * @param X - a parameter to do nothing with\n   * @returns `X`, the same as it was before\n   */\n  <X>(X: X): X;\n\n  /**\n   * Identity function.\n   *\n   * Exists to do nothing.\n   * @param X - a parameter to do nothing with\n   * @returns `X`, the same as it was before\n   */\n  (X: any): any;\n} = <X>(X: X): X => X;\n\nexport const isNull = (v: any): v is null | undefined => v == null;\nexport const isString = (v: any): v is string => typeof v === 'string';\n\nexport const testIf = <O>(condition: (x: any) => x is O) => <T>(\n  then: T\n) => (\n  otherValue: O | T\n) => condition(otherValue) ? then : otherValue;\n\n/**\n * Lazy defaulter.\n *\n * Helps with preventing `null`s or `undefined`s from sneaking into your values.\n *\n * @param defaultValue A value to take place\n * if a `null` or `undefined` comes instead of the original value\n *\n * @returns A function that accepts a nullable `original` value\n * and returns `defaultValue` if `original` is `undefined` or `null`,\n * `original` - otherwise\n */\nexport const ifNull = testIf(isNull);\n\n/**\n * Nullable operations generator factory.\n *\n * Powerful fail-safe mechanism.\n *\n * @param defaultValue - A default to use instead of the null value\n * @returns a safeguard function\n */\nexport function createSafeOperation<T>(defaultValue: T) {\n  return <U extends T, R>(\n    action: (x: Readonly<U>) => R\n  ) => compose(\n    action,\n    ifNull(defaultValue as U)\n  );\n}\n\nexport type Comparator<T> = (el1: T, el2: T) => boolean;\n\n/**\n * Compare two objects by a property\n * using a comparator function (default - `===`)\n *\n * @param key - property key to compare objects by\n * @param [compare=(el1, el2) => el1 === el2] - comparator to compare the properties by\n */\nexport const compareBy = <Key extends PropertyKey, TK = any>(\n  key: Key,\n  compare: Comparator<TK> = (el1, el2) => el1 === el2\n) => <T extends Record<Key, TK>>(\n  el1: T, el2: T\n) => compare(el1[key], el2[key]);\n","import { compose } from './compose';\nimport { createSafeOperation } from './generic';\nimport { Nullable } from './type';\n\n/**\n * Applies an operation to an object safely,\n * without failing on null or undefined\n */\nexport const safeObj = createSafeOperation<any>({} as any);\n\n/**\n * Maps object values by their keys (including symbols) into a new object\n *\n * Generaly equivalent to `Array.prototype.map()`\n */\nexport const mapObject = <T extends object, R>(\n  obj: T,\n  value: (key: keyof T) => R\n) => (\n  <Array<keyof T>>\n  [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)]\n).reduce((newObj, key) => (\n  newObj[key] = value(key), newObj\n), <Record<keyof T, R>> {});\n\n/**\n * Gets the array of keys of the given object (type-safe)\n */\nexport const keys = Object.keys.bind(Object) as <T extends object>(o: T) => Array<keyof T>;\n\n/**\n * Lazily gets a value by key chain from the object.\n *\n * Unsafe - fails when the object is `null` or `undefined`\n */\nexport const fromPath = (...path: string[]) => <T extends object>(obj: T): any => path.reduce((o, i) => (\n  Object(o) === o ? o[i] : o\n), obj);\n\nexport const key: {\n  /**\n   * Lazily gets a value by key from the object.\n   *\n   * Safe, doesn't fail even if the object is `null` or `undefined`.\n   */\n  <T, K extends keyof T>(key: K): (obj: Nullable<T>) => T[K];\n\n  /**\n   * Lazily gets a value by key chain from the object.\n   *\n   * Safe, doesn't fail even if the object is `null` or `undefined`.\n   */\n  (...keys: string[]): (obj: any) => any;\n} = compose(\n  safeObj,\n  fromPath\n);\n","import { add } from './number';\nimport { safeObj } from './object';\nimport { compose } from './compose';\nimport { id, createSafeOperation, ifNull, Comparator } from './generic';\nimport { Nullable } from './type';\n\nexport const safeArr = createSafeOperation<Array<any>>([]);\n\n/**\n * Lazy version of Array.prototype.map()\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param f - A callback for the map function.\n * @returns A function that maps an array into a different array using the remembered callback.\n */\nexport function map<T, R>(f: (x: T, i: number, arr: Readonly<T[]>) => R) {\n  return safeArr<T[], R[]>(_ => _.map<R>(f));\n}\n\n/**\n * Lazy version of Array.prototype.reduce()\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param f - A callback for the reduce function.\n * @returns A function that reduces an array using the remembered callback.\n */\nexport function reduce<T>(f: (p: T, c: T, i: number, arr: Readonly<T[]>) => T): (arr: Readonly<Nullable<T[]>>) => T;\n\n/**\n * Lazy version of Array.prototype.reduce()\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param f - A callback for the reduce function.\n * @param init - A callback for the reduce function.\n * @returns A function that reduces an array using the remembered callback.\n */\nexport function reduce<T, R = T>(\n  f: (p: R, c: T, i: number, arr: Readonly<T[]>) => R,\n  init: R\n): (arr: Readonly<Nullable<T[]>>) => R;\n\n/**\n * Lazy version of Array.prototype.reduce()\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param f - A callback for the reduce function.\n * @param [init] - [optional] A callback for the reduce function.\n * @returns A function that reduces an array using the remembered callback.\n */\nexport function reduce<T, R>(f: (p: R, c: T, i: number, arr: Readonly<T[]>) => R, init?: R): (arr: Readonly<Nullable<T[]>>) => R;\n\nexport function reduce<T, R>(\n  f: (p: R | T, c: T, i: number, arr: Readonly<T[]>) => R,\n  init?: R | T\n): (arr: Readonly<Nullable<T[]>>) => R | T {\n  return safeArr<T[], R | T>(_ => _.reduce(f, init as R | T));\n}\n\n/**\n * Lazy version of Array.prototype.reduceRight()\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param f - A callback for the reduce function.\n * @param [init] - [optional] A callback for the reduce function.\n * @returns A function that reduces an array backwards using the remembered callback.\n */\nexport function reduceRight<U, T>(f: (p: U, c: T, i: number, arr: Readonly<T[]>) => U, init: U) {\n  return safeArr<T[], U>(_ => _.reduceRight(f, init));\n}\n\n/**\n * Lazy version of Array.prototype.filter()\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param f - A callback for the filter function, should return a boolean.\n * @returns A function that filters an array using the remembered callback.\n */\nexport function filter<T>(f: (x: T, i: number, arr: readonly T[]) => boolean): (arr: Nullable<Readonly<T[]>>) => T[];\n/**\n * Lazy version of Array.prototype.filter()\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param f - A callback for the filter function, should return a boolean.\n * @returns A function that filters an array using the remembered callback.\n */\nexport function filter<T, R extends T>(f: (x: T, i: number, arr: readonly T[]) => x is R): (arr: Nullable<Readonly<T[]>>) => R[];\nexport function filter<T>(f: (x: T, i: number, arr: readonly T[]) => boolean): (arr: Nullable<Readonly<T[]>>) => T[] {\n  return safeArr<T[], T[]>(_ => _.filter(f));\n}\n\n\nexport function isOneOf<T>(...many: T[]) {\n  return (x: T) => many.includes(x);\n}\n\n/**\n * Lazy version of Array.prototype.join()\n *\n * Remembers the separator to join the array by it later on.\n *\n * In case of array being `null` or `undefined` just applies the callback to an empty array.\n *\n * @param separator - A string to join by.\n * @returns A function that joins an array using the remembered separator.\n */\nexport function join(separator: string = '') {\n  return safeArr(_ => _.join(separator));\n}\n\n/**\n * Pure version of Array.prototype.reverse()\n *\n * Doesn't modify the original array, returns a fresh and reversed one.\n *\n * In case of original array being `null` or `undefined` just returns an empty array.\n *\n * @param arr - Array to reverse.\n * @returns A new array with reverse order of elements.\n */\nexport function reverse<T>(arr?: T[] | null) {\n  return reduceRight<T[], T>((arr, el) => (arr.push(el), arr), [])(arr);\n}\n\n/**\n * Pure lazy version of Array.prototype.sort():\n * - if a callback returns a negative number - make `a` lower than `b`\n * - if a callback returns a 0 - leave order unchanged\n * - if a callback returns a positive number - make `b` lower than `a`\n *\n * Doesn't modify the original array, returns a fresh and sorted one.\n *\n * In case of original array being `null` or `undefined` just returns an empty array.\n *\n * @param f - a compare function.\n * @returns A function that accepts an array to sort.\n */\nexport function sort<T>(f?: (a: T, b: T) => number) {\n  return safeArr<T[], T[]>(_ => _.slice().sort(f));\n}\n\n/**\n * Lazy version of Array.prototype.slice(), which returns a section of an array.\n *\n * Remembers the arguments to apply them to the array.slice() later on.\n *\n * In case of array being `null` or `undefined` just applies the `slice()` to an empty array.\n *\n * @param [start] - The beginning of the specified portion of the array.\n * @param [end] - The end of the specified portion of the array.\n * @returns A function that slices an array using the remembered arguments.\n */\nexport function slice<T>(start?: number, end?: number) {\n  return safeArr<T[], T[]>(_ => _.slice(start, end));\n}\n\n/**\n * Lazy version of Array.prototype.some(),\n * which returns true if the callback yields `true` for at least one element of the array.\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the `some()` to an empty array.\n *\n * @param f - A callback for the `some()` function, should return a boolean.\n * @returns A function that checks the array using the remembered callback.\n */\nexport function some<T>(f: (x: T, i: number, array: readonly T[]) => boolean) {\n  return safeArr<T[], boolean>(_ => _.some(f));\n}\n\n/**\n * Lazy version of Array.prototype.every(),\n * which returns true if the callback yields `true` for every element of the array.\n *\n * Remembers the callback to apply it to the array later on.\n *\n * In case of array being `null` or `undefined` just applies the `every()` to an empty array.\n *\n * @param f - A callback for the `every()` function, should return a boolean.\n * @returns A function that checks the array using the remembered callback.\n */\nexport function every<T>(f: (x: T, i: number, array: readonly T[]) => boolean) {\n  return safeArr<T[], boolean>(_ => _.every(f));\n}\n\nexport function first<T>(arr?: Nullable<T[]>): T | undefined {\n  return safeArr<T[], T | undefined>(_ => _[0])(arr);\n}\n\nfirst.or = <T>(defaultValue: T) => compose<[Nullable<T[]>], Nullable<T>, T>(\n  ifNull(defaultValue),\n  first\n);\n\nexport function last<T>(arr?: Nullable<T[]>): Nullable<T> {\n  return safeArr<T[], T | undefined>(_ => _.length === 0 ? _[0] : _[_.length - 1])(arr);\n}\n\nlast.or = <T>(defaultValue: T) => compose<[Nullable<T[]>], Nullable<T>, T>(\n  ifNull(defaultValue),\n  last\n);\n\nconst isPropKey = <T = object>(v: any): v is keyof T => typeof v === 'string' || typeof v === 'number' || typeof v === 'symbol';\n\n/**\n * Provides overloads for applying some action on reducing the array.\n */\ntype ReduceAction<R> = {\n  /**\n   * Perform lazy action on the array\n   *\n   * @param f - A getter function to get an element suitable for action.\n   * @returns a function, which peforms the action on all elements in the array using the getter function `f`.\n   */\n  <T>(f: (x: T) => R): (arr: Nullable<T[]>) => R;\n\n\n  /**\n   * Perform lazy action on the array elements' props.\n   *\n   * @param prop - A string key of the prop of suitable type in an element of the array.\n   * @returns a function, which peforms the action on all given props of elements in the array.\n   */\n  <T>(prop: keyof T): (arr: Nullable<T[]>) => R;\n\n  /**\n   * Perform the action on the array elements.\n   *\n   * Works only on arrays of the given type.\n   *\n   * @returns a result of the action performed.\n   */\n  <T>(arr: Nullable<T[]>): R;\n};\n\n/**\n * Creates a function that performs an action on all elements of the array,\n * using the `reduce()` function.\n *\n * @param act - A reducing action to perform on the array elements\n * @param [init] - [optional] initial value for the `reduce` function\n * @returns a final action function\n */\nexport function action<R>(act: (a: R, b: R) => R, init?: R): ReduceAction<R> {\n  return function <T>(\n    arrOrProp?: Nullable<R[]> | keyof T | ((x: T) => R)\n  ) {\n    const getProp = typeof arrOrProp === 'function'\n      ? safeObj<T, R>(arrOrProp)\n      : isPropKey<T>(arrOrProp)\n        ? safeObj((_: T) => _[arrOrProp])\n        : id;\n\n    return reduce<T, R>((a, b) => act(a, getProp(b)), init);\n  } as ReduceAction<R>;\n}\n\ntype SummableKeys<T> = {\n  [key in keyof T]: T[key] extends string | number ? key : never\n}[keyof T];\n\n/**\n * Lazy summation (sum) of the array elements.\n */\nexport const sum: {\n  /**\n   * Lazy summation (sum) of the array elements.\n   *\n   * @param f - A getter function for a numbered element\n   * or a number representation of an element of the array.\n   * @returns a function, which sums all elements in the array using the getter function `f`.\n   */\n  <T>(f: (x: T) => number): (arr: Nullable<T[]>) => number;\n\n  /**\n   * Lazy summation (sum) of the array elements' props.\n   *\n   * @param prop - A string key of the prop of type `number` in an element of the array.\n   * @returns a function, which sums all given props of elements in the array.\n   */\n  <T>(prop: SummableKeys<T>): (arr: Nullable<T[]>) => number;\n\n  /**\n   * Summation (sum) of the array elements.\n   *\n   * Works only on arrays of numbers.\n   *\n   * @returns a sum of all numbers in the array.\n   */\n  (arr: Nullable<number[]>): number;\n} = action<number>(add, 0);\n\n/**\n * Checks the uniqeness of an array item based on a comparator function\n *\n * @param equals a function that determines if two elements are equal\n */\nexport const isElementUnique = <T>(\n  equals: Comparator<T> = (a, b) => a === b\n) => (el: T, i: number, arr: readonly T[]) => arr.findIndex(newEl => equals(newEl, el)) === i;\n\n/**\n * Removes duplicates from an array based on the result of an `equals` function\n *\n * @param equals a function that determines if two elements are equal\n */\nexport const unique = <T>(equals: Comparator<T> = (a, b) => a === b) => filter<T>(\n  isElementUnique<T>(equals)\n);\n","/**\n * Creates a boolean composer based on a boolean operator function\n *\n * @param operator a function that takes two boolean and returns another boolean\n * @returns a composer of boolean-returning operations\n */\nexport function composeBools(operator: (left: boolean, right: boolean) => boolean) {\n  return function <T>(...fns: Array<(x: T, i: number, arr: readonly T[]) => boolean>) {\n    return fns.reduce((lf, rf) => (x: T, i, arr) => operator(lf(x, i, arr), rf(x, i + 1, arr)));\n  };\n}\n\n/**\n * Composes boolean-returning operations together using \"and\" operation\n *\n * @returns a function that computes the result for an element\n */\nexport const and = composeBools((l, r) => l && r);\n\n/**\n * Composes boolean-returning operations together using \"or\" operation\n *\n * @returns a function that computes the result for an element\n */\nexport const or = composeBools((l, r) => l || r);\n\n/**\n * Composes boolean-returning operations together using \"xor\" operation\n *\n * @returns a function that computes the result for an element\n */\nexport const either = composeBools((l, r) => (l && !r) || (r && !l));\n\n/**\n * Inverses a boolean-returning function\n *\n * ```ts\n * const isNotArray = not(Array.isArray);\n * ```\n *\n * @param f a function that returns a boolean\n * @returns the same function but with inversed boolean output\n */\nexport const not = <F extends (...args: any[]) => boolean>(f: F): F => ((...args: Parameters<F>) => !f(...args)) as F;\n","/**\n * Makes a pure identity function out of any logging function\n *\n * @param messager - the logging function to purify\n */\nconst purifyLog = (messager: (...messages: any) => void) => (...messages: any) => <T>(x: T) => (messager(...messages, x), x);\n\n/** Lazily logs the element in the composition chain with some messages */\nexport const log = purifyLog(console.log);\n\n/** Lazily logs via console.warn the element in the composition chain with some messages */\nexport const warn = purifyLog(console.warn);\n\n/** Lazily errors (via console.error) the element in the composition chain with some messages */\nexport const error = purifyLog(console.error);\n","const recordExistsIn = (cache: Record<string, any>) => (paramsHash: string) => typeof cache[paramsHash] !== 'undefined';\nconst hashFunction = <P extends any[]>(\n  hash?: (...args: P) => string\n): ((args: P) => string) => hash ? (_: P) => hash(..._) : JSON.stringify;\n\n/**\n * Creates a function which caches its result based on parameters.\n * It's possible to customize the caching behaviour using the second argument - [hash].\n *\n * Works well with long, expensive computations, such as API requests or array operations.\n *\n *\n * @param f - A function to be cached.\n * Can only be a PURE function, e.g. a function which always gives the same output, given the same input.\n * @param [hash] - Custom hash function for parameters. Accepts all of the function's parameters,\n * should return a string, which will then be used as a hash key.\n * @returns - A cached function,\n * virtually identical to the original.\n */\nexport function memoize<\n  F extends (...args: any) => any\n>(f: F, hash?: (...args: Parameters<F>) => string): F & { original: F } {\n  const cache: Record<string, any> = {};\n  const isCached = recordExistsIn(cache);\n  const hashParams = hashFunction(hash);\n\n  const memoized = function (...args: any[]) {\n    const hashedArgs = hashParams(args as Parameters<F>);\n\n    let result: ReturnType<F>;\n\n    if (isCached(hashedArgs)) {\n      result = cache[hashedArgs];\n    } else {\n      result = cache[hashedArgs] = f(...args);\n    }\n\n    return result;\n  } as F & { original: F };\n\n  memoized.original = f;\n\n  return memoized;\n}\n\n/**\n * A decorator factory for memoization of class methods.\n *\n * ```ts\n * class MathJS {\n *   \\@Memoize((a, b) => (a + b))\n *   add(a: number, b: number) {\n *     return fetch(`http://api.mathjs.org/v4/?expr=${a}+${b}`)\n *       .then(_ => _.json());\n *   }\n * }\n *\n * // Then\n *\n * const math = new MathJS();\n *\n * math.add(2, 3);\n * // Request sent to `http://api.mathjs.org/v4/?expr=2+3` ...\n * // Delay...\n * // Result: `Promise<5>`\n *\n * // After some time, we call it again:\n * math.add(2, 3);\n * // Result: `Promise<5>`\n * // No delays! Value from local cache!\n * ```\n *\n * @param [hash] - Custom hash function for parameters. Accepts all of the methods's parameters,\n * should return a string, which will then be used as a hash key.\n */\nexport function Memoize(hash?: (...args: any[]) => string): MethodDecorator {\n  return function (target, key, desc) {\n    Object.defineProperty(target, key, {\n      ...desc,\n      value: memoize(desc.value as any, hash),\n    });\n\n    return Object.getOwnPropertyDescriptor(target, key);\n  };\n}\n","import { createSafeOperation } from './generic';\nimport { GetFKeys, GetF } from './type';\n\nexport const safeStr = createSafeOperation<string>('');\n\n/**\n * Lazifies any String.prototype method - makes it lazy and composable.\n *\n * @param methodName - the name of the method to uncurry\n * @returns a new lazy pure function\n */\nfunction lazyStrMethod<M extends GetFKeys<String>>(methodName: M) {\n  const method: Function = String.prototype[methodName];\n\n  return (...args: Parameters<GetF<String, M>>) => safeStr(\n    (s): ReturnType<GetF<String, M>> => method.apply(s, args)\n  );\n}\n\n/**\n * Lazily matches a pattern that supports being matched against,\n * and returns function that returns an array containing the results of that search.\n * @param matcher An object that supports being matched against\n * @returns a function that performs the given match on a string argument\n */\nexport const match = (pattern: RegExp) => safeStr(s => s.match(pattern) || []);\n\n/**\n * Finds the first substring match in a regular expression search.\n * @param pattern The regular expression pattern and applicable flags.\n */\nexport const search = (pattern: string | RegExp) => safeStr(s => s.search(pattern));\n\n/**\n * Lazily returns a check function that indicates\n * whether or not a pattern exists in a searched string.\n *\n * @param matcher An object that supports being matched against\n * @returns a function that performs the given test on a string argument\n */\nexport const test = (pattern: RegExp) => safeStr(s => pattern.test(s));\n\nexport const replace: {\n  (match: RegExp | string, replace: string): (s: string) => string;\n  (match: RegExp | string, replacer: (substring: string, ...args: any[]) => string): (s: string) => string;\n} = lazyStrMethod('replace') as any;\n\nexport const prepend = (prefix: string) => safeStr(s => prefix.concat(s));\n\n/**\n * Returns a string that contains the concatenation of two or more strings.\n * @param args The strings to append to the end of the string.\n */\nexport const append = lazyStrMethod('concat');\n\n/**\n * Lazily split a string into substrings using the specified separator and return them as an array.\n * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.\n * @param limit A value used to limit the number of elements returned in the array.\n */\nexport const split = (separator: string | RegExp, limit?: number) => safeStr(s => s.split(separator, limit));\n\n/**\n * Gets a substring beginning at the specified location and having the specified length.\n * @param from The starting position of the desired substring. The index of the first character in the string is zero.\n * @param length The number of characters to include in the returned substring.\n */\nexport const substr = lazyStrMethod('substr');\n\n/** Converts all the alphabetic characters in a string to uppercase. */\nexport const toUpperCase = lazyStrMethod('toUpperCase')();\n\n/** Converts all the alphabetic characters in a string to lowercase. */\nexport const toLowerCase = lazyStrMethod('toLowerCase')();\n\n/** Removes the leading and trailing white space and line terminator characters from a string. */\nexport const trim = lazyStrMethod('trim')();\n\nexport const startsWith = lazyStrMethod('startsWith');\n\nexport const endsWith = lazyStrMethod('endsWith');\n\nexport const getDigits = replace(/[^0-9]/g, '');\n","export function then<T, R>(res: (x: T) => R): (px: Promise<T>) => R extends Promise<infer RR> ? Promise<RR> : Promise<R> {\n  return (px: Promise<T>) => px.then(res) as any;\n}\n\nexport function capture<T, R>(rej: (e: any) => R): (px: Promise<T>) => Promise<T | R> {\n  return (px: Promise<T>) => px.catch(rej);\n}\n"],"names":["curry","fn","arity","length","curried","args","bind","add","a","b","subtract","multiply","divide","pow","Math","toFixed","digits","x","toPrecision","toExponential","compose","fns","reduceRight","arg","_","id","X","isNull","v","testIf","condition","then","otherValue","ifNull","createSafeOperation","defaultValue","action","safeObj","keys","Object","fromPath","path","obj","reduce","o","i","key","safeArr","f","init","filter","first","arr","last","or","isPropKey","_typeof","act","arrOrProp","getProp","sum","isElementUnique","equals","el","findIndex","newEl","composeBools","operator","lf","rf","and","l","r","either","purifyLog","messager","messages","log","console","warn","error","recordExistsIn","cache","paramsHash","hashFunction","hash","JSON","stringify","memoize","isCached","hashParams","memoized","hashedArgs","original","safeStr","lazyStrMethod","methodName","method","String","prototype","s","apply","replace","append","substr","toUpperCase","toLowerCase","trim","startsWith","endsWith","getDigits","target","desc","defineProperty","value","getOwnPropertyDescriptor","rej","px","compare","el1","el2","concat","every","includes","many","separator","join","map","getOwnPropertySymbols","newObj","pattern","match","prefix","push","search","start","end","slice","some","sort","limit","split","test","res"],"mappings":"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"}